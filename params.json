{
  "name": "Nohttp",
  "tagline": "Android Http标准框架，底层OkHttp，与RxJava完美结合，比Retrofit更简单易用。",
  "body": "# NoHttp，一个有情怀的网络框架\r\n![NoHttp Logo](http://www.nohttp.net/image/nohttp_logo.svg)  \r\n\r\n严振杰的博客：[blog.yanzhenjie.com](http://blog.yanzhenjie.com)   \r\n\r\nNoHttp重要升级，支持与`RxJava`完美结合、支持一句话切换底层为`OkHttp`，支持请求Restful风格的接口，比Retrofit更简单易用。  \r\n\r\n**欢迎加入QQ交流群：[547839514](http://jq.qq.com/?_wv=1027&k=40Qqms0)**\r\n\r\n----\r\n\r\n## 导航目录(点击可跳转到对应节点处)\r\n- [Demo效果预览](#效果预览)  \r\n- [NoHttp特性](#框架特性)  \r\n- [AndroidStuio、Eclipse使用方法](#使用方法)  \r\n- [NoHttp初始化](#初始化)  \r\n- [需要的权限](#权限)  \r\n- [友好的调试模式](#友好的调试模式)  \r\n- [RxJava](#第三方异步框架)  \r\n- [请求队列](#请求队列)  \r\n- [String、Bitmap、JavaBean、Json请求](#几种数据类型请求)  \r\n- [添加参数，可以链式调用](#添加参数)  \r\n- [提交Json、XML、自定义Body等](#提交请求包体)  \r\n- [同步请求](#同步请求)  \r\n- [五大缓存模式](#五大缓存模式)  \r\n- [文件下载](#文件下载)  \r\n- [如何取消请求](#取消请求)  \r\n- [停止队列](#停止队列)  \r\n- [自定义请求](#自定义请求)  \r\n- [代码混淆](#代码混淆)  \r\n\r\n## 效果预览\r\n<image src=\"https://github.com/yanzhenjie/NoHttp/blob/master/image/1.gif?raw=true\" width=\"280px\"/>  <image src=\"https://github.com/yanzhenjie/NoHttp/blob/master/image/2.gif?raw=true\" width=\"280px\"/>  \r\n\r\n<image src=\"https://github.com/yanzhenjie/NoHttp/blob/master/image/3.gif?raw=true\" width=\"280px\"/>  <image src=\"https://github.com/yanzhenjie/NoHttp/blob/master/image/4.gif?raw=true\" width=\"280px\"/>\r\n\r\n## 框架特性\r\n比Retrofit使用更简单、更易用。\r\n\r\n* 动态配置底层框架为**OkHttp**、HttpURLConnection\r\n* 与**RxJava**完美结合，支持异步请求、支持同步请求\r\n* 多文件上传，支持大文件上传，表单提交数据\r\n* 文件下载、上传下载、上传和下载的进度回调、错误回调\r\n* 支持Json、xml、Map、List的提交\r\n* 完美的Http缓存模式，可指定缓存到数据库、SD卡，缓存数据已安全加密\r\n * 在6.0以上手机缓存到SD卡时需要请求运行时权限：[AndPermission](https://github.com/yanzhenjie/AndPermission)\r\n* 自定义Request，直接请求JsonObject、JavaBean等\r\n* Cookie的自动维持，App重启、关开机后还持续维持\r\n* http 301 302 303 304 307重定向，支持多层嵌套重定向\r\n* Https、自签名网站Https的访问、支持双向验证\r\n* 失败重试机制，支持请求优先级\r\n* GET、POST、PUT、PATCH、HEAD、DELETE、OPTIONS、TRACE等请求协议\r\n* 用队列保存请求，平均分配多线程的资源，支持多个请求并发\r\n* 支持取消某个请求、取消指定多个请求、取消所有请求\r\n\r\n## 使用方法\r\n### AndroidStudio使用方式\r\n* 如果使用HttpURLConnection作为网络层：  \r\n```groovy\r\ncompile 'com.yolanda.nohttp:nohttp:1.1.0'\r\n```\r\n* 如果要使用OkHttp作为网络层，请再依赖：  \r\n```groovy\r\ncompile 'com.yanzhenjie.nohttp:okhttp:1.1.0'\r\n```\r\n\r\n### Eclipse使用方式\r\n* 如果使用HttpURLConnection作为网络层：  \r\n [下载NoHttp Jar包](https://github.com/yanzhenjie/NoHttp/blob/master/Jar/nohttp1.1.0.jar?raw=true)  \r\n* 如果使用OkHttp做为网络层  \r\n [下载NoHttp-OkHttp Jar包](https://github.com/yanzhenjie/NoHttp/blob/master/Jar/nohttp-okhttp1.1.0.jar?raw=true)，并且请自行下载[okhttp](https://github.com/square/okhttp)、[okio](https://github.com/square/okio)的jar包。\r\n\r\n* 建议没用Android的同学尽早切换到AndroidStudio来开发Android应用。\r\n\r\n## 初始化\r\nNoHttp初始化需要一个Context，最好在`Application`的`onCreate()`中初始化，记得在`manifest.xml`中注册`Application`。\r\n\r\n### 一般情况下只需要这样初始化\r\n直接初始化后，一切采用默认设置。\r\n```java\r\nNoHttp.initialize(this);\r\n```\r\n\r\n### 如果需要自定义配置更多信息\r\n\r\n* 超时配置，默认10s\r\n```java\r\nNoHttp.initialize(this, new NoHttp.Config()\r\n    // 设置全局连接超时时间，单位毫秒\r\n    .setConnectTimeout(30 * 1000)\r\n    // 设置全局服务器响应超时时间，单位毫秒\r\n    .setReadTimeout(30 * 1000)\r\n);\r\n```\r\n\r\n* 配置缓存，默认保存在数据库\r\n```java\r\nNoHttp.initialize(this, new NoHttp.Config()\r\n    ...\r\n    // 保存到数据库\r\n    .setCacheStore(\r\n        new DBCacheStore(this).setEnable(true) // 如果不使用缓存，设置false禁用。\r\n    )\r\n    // 或者保存到SD卡\r\n    .setCacheStore(\r\n        new DiskCacheStore(this)\r\n    )\r\n);\r\n```\r\n\r\n* 配置Cookie保存的位置，默认保存在数据库\r\n```java\r\nNoHttp.initialize(this, new NoHttp.Config()\r\n    ...\r\n    // 默认保存数据库DBCookieStore，开发者可以自己实现。\r\n    .setCookieStore(\r\n        new DBCookieStore(this).setEnable(false) // 如果不维护cookie，设置false禁用。\r\n    )\r\n);\r\n```\r\n\r\n* 配置网络层\r\n```java\r\nNoHttp.initialize(this, new NoHttp.Config()\r\n    ...\r\n    // 使用HttpURLConnection\r\n    .setNetworkExecutor(new URLConnectionNetworkExecutor())\r\n    // 使用OkHttp\r\n    .setNetworkExecutor(new OkHttpNetworkExecutor())\r\n);\r\n```\r\n\r\n## 权限\r\n```xml\r\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\r\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\r\n```\r\n\r\n## 友好的调试模式\r\n```java\r\nLogger.setDebug(true);// 开启NoHttp的调试模式, 配置后可看到请求过程、日志和错误信息。\r\nLogger.setTag(\"NoHttpSample\");// 设置NoHttp打印Log的tag。\r\n```\r\n开启NoHttp的调试模式后可看到请求过程、日志和错误信息，基本不用抓包。可以看到请求头、请求数据、响应头、Cookie等，而且打印出的Log非常整齐。\r\n\r\n所以说，如果你使用过程中遇到什么问题了，开启调试模式，一切妖魔鬼怪都会现形的。\r\n\r\n## 第三方异步框架\r\n可以与RxJava、RxAndroid、RxBus、EventBus等第三方异步任务框架完美结合使用，这里在demo中给出了和RxJava一起使用的代码。\r\n\r\n### RxJava\r\nNoHttp可以和RxJava完美结合，这里列出如何使用，具体的封装请参考Demo的RxNoHttp。\r\n```java\r\nRequest<UserInfo> request = new JavaBeanRequest<>(url, UserInfo.class);\r\nRxNoHttp.request(this, request, new SimpleSubscriber<Response<UserInfo>>() {\r\n    @Override\r\n    public void onNext(Response<YanZhenjie> entityResponse) {\r\n        // 直接拿到实体对象\r\n        UserInfo userInfo = entiryResponse.get();\r\n    }\r\n});\r\n```\r\n\r\n## 请求队列\r\n```java\r\nRequestQueue requestQueue = NoHttp.newRequestQueue();\r\n// 如果要指定并发值，传入数字即可：NoHttp.newRequestQueue(3);\r\n\r\n// 发起请求\r\nrequestQueue.add(what, request, responseListener);\r\n```\r\n* 添加请求到队列时有一个what，这个what会在`responseLisetener`响应时回调给开发者，所以开发者可以用一个`responseLisetener`接受多个请求的响应，用what来区分结果。而不用像有的框架一样，每一个请求都要new一个callback。  \r\n* **强烈建议**把生成队列写成懒汉单例模式，因为每新建队列就会new出相应个数的线程来，同时只有线程数固定了，队列的作用才会发挥到最大。\r\n\r\n## 几种数据类型请求\r\n### String请求\r\n```java\r\nRequest<String> request = NoHttp.createStringRequest(url, RequestMethod.GET);\r\nrequestQueue.add(0, request, listener);\r\n```\r\n\r\n### Json请求\r\n```java\r\n// JsonObject\r\nRequest<JSONObject> objRequest = NoHttp.createJsonObjectRequest(url, RequestMethod.POST);\r\nrequestQueue.add(0, objRequest, listener);\r\n\r\n// JsonArray\r\nRequest<JSONArray> arrayRequest = NoHttp.createJsonArrayRequest(url, RequestMethod.PUT);\r\nrequestQueue.add(0, arrayRequest, listener);\r\n```\r\n\r\n### Bitmap请求\r\n```\tjava\r\nRequest<Bitmap> request = NoHttp.createImageRequest(url, RequestMethod.DELETE);\r\nrequestQueue.add(0, request, listener);\r\n```\r\n\r\n### 请求FastJson与Gson\r\n```java\r\n// FastJson\r\nRequest<JSONObject> request = new FastJsonRequest(url, RequestMethod.POST);\r\nrequestQueue.add(0, request, listener);\r\n```\r\n\r\n### 直接请求JavaBean\r\n```java\r\n// 内部使用Gson、FastJson解析成JavaBean\r\nRequest<UserInfo> request = new JavaBeanRequest(url, RequestMethod.GET);\r\nrequestQueue.add(0, request, listener);\r\n```\r\n\r\n## 添加参数\r\n```java\r\nRequest<JSONObject> request = new JavaBeanRequest(url, RequestMethod.POST);\r\n   .add(\"name\", \"yoldada\") // String类型\r\n   .add(\"age\", 18) // int类型\r\n   .add(\"sex\", '0') // char类型\r\n   .add(\"time\", 16346468473154) // long类型\r\n\r\n   // 添加Bitmap\r\n   .add(\"head\", new BitmapBinary(bitmap))\r\n   // 添加File\r\n   .add(\"head\", new FileBinary(file))\r\n   // 添加ByteArray\r\n   .add(\"head\", new ByteArrayBinary(byte[]))\r\n   // 添加InputStream\r\n   .add(\"head\", new InputStreamBinary(inputStream));\r\n```\r\n\r\n文件上传实现了http表单的标准协议，满足了广大开发者的需求，有以下几种形式：\r\n\r\n* 单个文件\r\n```java\r\nRequest<String> request = ...\r\nrequest.add(\"file\", new FileBinary(file));\r\n```\r\n\r\n* 上传多个文件、多个Key多个文件形式  \r\n这里可以添加各种形式的文件，File、Bitmap、InputStream、ByteArray。\r\n\r\n```java\r\nRequest<String> request = ...\r\nrequest.add(\"file1\", new FileBinary(File));\r\nrequest.add(\"file2\", new FileBinary(File));\r\nrequest.add(\"file3\", new InputStreamBinary(InputStream));\r\nrequest.add(\"file4\", new ByteArrayBinary(byte[]));\r\nrequest.add(\"file5\", new BitmapBinary(Bitmap));\r\n```\r\n\r\n* 上传多个文件、一个Key多个文件形式\r\n```java\r\nRequest<String> request = ...\r\nfileList.add(\"image\", new FileBinary(File));\r\nfileList.add(\"image\", new InputStreamBinary(InputStream));\r\nfileList.add(\"image\", new ByteArrayBinary(byte[]));\r\nfileList.add(\"image\", new BitmapBinary(Bitmap));\r\n```\r\n\r\n或者：  \r\n```java\r\nRequest<String> request = ...\r\n\r\nList<Binary> fileList = ...\r\nfileList.add(new FileBinary(File));\r\nfileList.add(new InputStreamBinary(InputStream));\r\nfileList.add(new ByteArrayBinary(byte[]));\r\nfileList.add(new BitmapStreamBinary(Bitmap));\r\nrequest.add(\"file_list\", fileList);\r\n```\r\n\r\n## 提交请求包体\r\n提交Body分为提交Json、提交String、提交Xml、提交流等，具体用法如下：\r\n```java\r\n// 提交普通String\r\nrequest.setDefineRequestBody(String, ContentType);\r\n\r\n// 提交json字符串\r\nrequest.setDefineRequestBodyForJson(JsonString)\r\n\r\n// 提交jsonObject对象，其实还是json字符串\r\nrequest.setDefineRequestBodyForJson(JSONObject)\r\n\r\n// 提交xml字符串\r\nrequest.setDefineRequestBodyForXML(XmlString)\r\n\r\n// 提交字体Body，比如File（这跟表单上传不一样的），可以转为InputStream来提交\r\nrequest.setDefineRequestBody(InputStream, ContentType)\r\n```\r\n\r\n## 同步请求\r\n在当前线程发起请求，在线程这么使用。\r\n```java\r\nRequest<String> request = NoHttp.createStringRequest(url, RequestMethod.DELETE);\r\nResponse<String> response = NoHttp.startRequestSync(request);\r\nif (response.isSucceed()) {\r\n    // 请求成功\r\n} else {\r\n    // 请求失败\r\n}\r\n```\r\n\r\n## 五大缓存模式\r\nNoHttp的缓存非常强大，支持缓存到数据库、换到SD卡等，并且不论缓存在数据库或者SD，NoHttp都把数据进行了加密，需要在初始化的时候配置缓存的位置。\r\n\r\n需要注意的是，在6.0以上的手机中如果要缓存在SD卡，需要在请求之前，需要请求运行时权限，如果你不懂运行时权限，可以看这个项目：[AndPermission](https://github.com/yanzhenjie/AndPermission)。\r\n```java\r\nNoHttp.initialize(this, new NoHttp.Config()\r\n    ...\r\n    // 保存到数据库\r\n    .setCacheStore(\r\n        new DBCacheStore(this).setEnable(true) // 如果不使用缓存，设置false禁用。\r\n    )\r\n    // 或者保存到SD卡\r\n    .setCacheStore(\r\n        new DiskCacheStore(this)\r\n    )\r\n);\r\n```\r\n\r\n\r\n* 1、Default模式，实现http 304重定向缓存\r\nNoHttp本身是实现了RFC2616，所以这里不用设置或者设置为DEFAULT。\r\n```java\r\nRequest<JSONObject> request = NoHttp.createJsonObjectRequest(url);\r\nrequest.setCacheMode(CacheMode.DEFAULT);\r\n```\r\n\r\n* 2、 当请求服务器失败的时候，读取缓存\r\n请求服务器成功则返回服务器数据，如果请求服务器失败，读取缓存数据返回。\r\n```java\r\nRequest<JSONObject> request = NoHttp.createJsonObjectRequest(url);\r\nrequest.setCacheMode(CacheMode.REQUEST_NETWORK_FAILED_READ_CACHE);\r\n```\r\n\r\n* 3、如果发现有缓存直接成功，没有缓存才请求服务器\r\n我们知道ImageLoader的核心除了内存优化外，剩下一个就是发现把内地有图片则直接使用，没有则请求服务器，所以NoHttp这一点非常使用做一个ImageLoader。  \r\n\r\n请求String，缓存String：\r\n```java\r\nRequest<JSONObject> request = NoHttp.createJsonObjectRequest(url);\r\n// 非标准Http协议，改变缓存模式为IF_NONE_CACHE_REQUEST_NETWORK\r\nrequest.setCacheMode(CacheMode.IF_NONE_CACHE_REQUEST_NETWORK);\r\n```\r\n\r\n请求图片，缓存图片：\r\n```java\r\nRequest<Bitmap> request = NoHttp.createImageRequest(imageUrl);\r\nrequest.setCacheMode(CacheMode.IF_NONE_CACHE_REQUEST_NETWORK);\r\n```\r\n\r\n* 4、仅仅请求网络\r\n这里不会读取缓存，也不支持Http304。\r\n```java\r\nRequest<Bitmap> request = NoHttp.createImageRequest(imageUrl);\r\nrequest.setCacheMode(CacheMode.ONLY_REQUEST_NETWORK);\r\n...\r\n```\r\n\r\n* 5、仅仅读取缓存\r\n仅仅读取缓存，不会请求网络和其它操作。\r\n```java\r\nRequest<Bitmap> request = NoHttp.createImageRequest(imageUrl);\r\nrequest.setCacheMode(CacheMode.ONLY_READ_CACHE);\r\n```\r\n\r\n## 文件下载\r\n因为下载文件代码比较多，这里贴关键部分，具体的请参考demo。  \r\n\r\n文件下载也是队列，队列和开头所说的请求的队列是一样的。\r\n\r\n- 发起下载请求\r\n```java\r\n//下载文件\r\ndownloadRequest = NoHttp.createDownloadRequest...\r\n// what 区分下载\r\n// downloadRequest 下载请求对象\r\n// downloadListener 下载监听\r\ndownloadQueue.add(0, downloadRequest, downloadListener);\r\n```\r\n\r\n- 暂停或者停止下载\r\n```java\r\ndownloadRequest.cancel();\r\n```\r\n\r\n- 监听下载过程\r\n```java\r\nprivate DownloadListener downloadListener = new DownloadListener() {\r\n\t@Override\r\n\tpublic void onStart(int what, boolean resume, long preLenght, Headers header, long count) {\r\n\t    // 下载开始\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onProgress(int what, int progress, long downCount) {\r\n\t\t// 更新下载进度\r\n\t}\r\n\r\n \t@Override\r\n\tpublic void onFinish(int what, String filePath) {\r\n\t    // 下载完成\r\n \t}\r\n\r\n\t@Override\r\n\tpublic void onDownloadError(int what, StatusCode code, CharSequence message) {\r\n\t    // 下载发生错误\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void onCancel(int what) {\r\n\t    // 下载被取消或者暂停\r\n\t}\r\n};\r\n```\r\n\r\n## 取消请求\r\nNoHttp支持取消某个请求、取消指定多个请求、取消所有请求。\r\n\r\n* 取消单个请求  \r\n直接调用请求对象的cancel方法。\r\n```java\r\nrequest.cancel();\r\n```\r\n\r\n* 从队列中取消指定的请求\r\n在请求之前给请求set一个sign，取消的时候调用队列的cancelBySign就可以取消掉所有指定这个sign的请求。\r\n```java\r\nrequest1.setCancelSign(sign);\r\nrequest2.setCancelSign(sign);\r\n...\r\n\r\n// 取消队列中多个用sign标志的请求\r\nqueue.cancelBySign(sign);\r\n```\r\n\r\n* 取消队列中所有请求\r\n```java\r\nqueue.cancelAll();\r\n```\r\n\r\n## 停止队列\r\n队列停止后再添加请求到队列后，请求不会被执行。\r\n```java\r\nRequestQueue queue = NoHttp.newRequestQueue();\r\n...\r\n\r\nqueue.stop();\r\n```\r\n\r\n## 自定义请求\r\n* FastJsonRequest\r\n```java\r\npublic class FastJsonRequest extends RestRequestor<JSONObject> {\r\n\r\n    public FastJsonRequest(String url) {\r\n\t    this(url, RequestMethod.GET);\r\n    }\r\n\r\n    public FastJsonRequest(String url, RequestMethod requestMethod) {\r\n\t    super(url, requestMethod);\r\n    }\r\n\r\n    @Override\r\n    public JSONObject parseResponse(Headers header, byte[] body) throws Throwable {\r\n\t    String result = StringRequest.parseResponseString(headers, body);\r\n\t    return JSON.parseObject(result);\r\n    }\r\n}\r\n```\r\n\r\n* JavaBeanRequest，利用FastJson、Gson等把数据直接转为JavaBean\r\n```java\r\npublic class JavaBeanRequest<T> extends RestRequest<T> {\r\n    private Class<T> clazz;\r\n\r\n    public JavaBeanRequest(String url, Class<T> clazz) {\r\n        this(url, RequestMethod.GET, clazz);\r\n    }\r\n\r\n    public JavaBeanRequest(String url, RequestMethod requestMethod, Class<T> clazz) {\r\n        super(url, requestMethod);\r\n        this.clazz = clazz;\r\n    }\r\n\r\n    @Override\r\n    public T parseResponse(Headers header, byte[] body) throws Throwable {\r\n        String response = StringRequest.parseResponseString(header, body);\r\n\r\n        // 这里如果数据格式错误，或者解析失败，会在失败的回调方法中返回 ParseError 异常。\r\n        return JSON.parseObject(response, clazz);\r\n    }\r\n}\r\n```\r\n\r\n* 使用自定义请求\r\n```java\r\n// 使用FastJson自定义请求\r\nRequest<JSONObject> request = new FastJsonRequest(url, requestMethod);\r\nqueue.add(what, mRequest, listener);\r\n\r\n...\r\n\r\n// 直击请求JavaBean\r\nRequest<UserInfo> request = new JavaBeanRequest(url, UserInfo.class);\r\nqueue.add(what, request, listener);\r\n```\r\n\r\n## 代码混淆\r\n1. NoHttp全部的类都可以混淆。  \r\n2. NoHttp设计到兼容高版本系统的api采用反射调用，所以所有类都可以被混淆  \r\n\r\n3. 如果你非要keep的话，如下配置即可  \r\n```text\r\n-dontwarn com.yolanda.nohttp.**\r\n-keep class com.yolanda.nohttp.**{*;}\r\n```\r\n\r\n## License\r\n```text\r\nCopyright 2016 Yan Zhenjie\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n   http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}